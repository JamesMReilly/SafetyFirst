module SafetyFirst.Array

open ResultDotNet.FSharp

open SafetyFirst.ErrorTypes

/// Returns the average of the elements in the array.
/// Returns a SeqIsEmpty error if <c>source</c> has no elements.
let inline averageSafe source = 
  if Array.isEmpty source
  then Error <| avgErr ()
  else Ok <| Array.average source

/// Returns the average of the elements in the array.
/// Returns a SeqIsEmpty error if <c>source</c> has no elements.
let inline average' source = averageSafe source 

/// Returns the average of the results generated by applying the function to each element
/// of the array.
/// Returns a SeqIsEmpty error if <c>xs</c> has no elements.
let inline averageBySafe selector xs = 
  if Array.isEmpty xs
  then Error <| avgErr ()
  else Ok <| Array.averageBy selector xs

/// Returns the average of the results generated by applying the function to each element
/// of the array.
/// Returns a SeqIsEmpty error if <c>xs</c> has no elements.
let inline averageBy' selector xs = averageBySafe selector xs

/// Divides the input array into chunks of size at most <c>size</c>.
/// Returns a NegativeInput Error if the <c>size</c> is less than zero.
let chunkBySizeSafe size xs =
  if size <= 0 
  then Error chunkErr
  else Ok <| Array.chunkBySize size xs

/// Divides the input array into chunks of size at most <c>size</c>.
/// Returns a NegativeInput Error if the <c>size</c> is less than zero.
let inline chunkBySize' size xs = chunkBySizeSafe size xs

/// If the input array has only one element, returns that element.
/// If the input array has more or less than one element, returns a WrongNumberOfElements Error.  
let exactlyOneSafe xs =
  match Array.length xs with
  | 1 -> Ok <| Array.head xs
  | 0 -> Error lessThanOneErr
  | _ -> Error moreThanOneErr 

/// If the input array has only one element, returns that element.
/// If the input array has more or less than one element, returns a WrongNumberOfElements Error.  
let inline exactlyOne' xs = exactlyOneSafe xs

/// Returns the first element for which the given function returns True.
/// Returns a NoMatchingElement Error if no such element is found.
let findSafe predicate xs = 
  Array.tryFind predicate xs 
  |> Result.ofOption findErr

/// Returns the first element for which the given function returns True.
/// Returns a NoMatchingElement Error if no such element is found.
let inline find' predicate xs = findSafe predicate xs

/// Returns the last element for which the given function returns True.
/// Return a NoMatchingElement Error if no such element exists.
let findBackSafe predicate xs = 
  Array.tryFindBack predicate xs
  |> Result.ofOption findErr

/// Returns the last element for which the given function returns True.
/// Return a NoMatchingElement Error if no such element exists.
let inline findBack' predicate xs = findBackSafe predicate xs

/// Returns the index of the first element in the array
/// that satisfies the given predicate.
/// Return a NoMatchingElement Error if no such element exists.
let findIndexSafe predicate xs = 
  Array.tryFindIndex predicate xs
  |> Result.ofOption findErr

/// Returns the index of the first element in the array
/// that satisfies the given predicate.
/// Return a NoMatchingElement Error if no such element exists.
let inline findIndex' predicate xs = findIndexSafe predicate xs

/// Returns the index of the last element in the array
/// that satisfies the given predicate.
/// Return a NoMatchingElement Error if no such element exists.
let findIndexBackSafe predicate xs = 
  Array.tryFindIndexBack predicate xs
  |> Result.ofOption findErr

/// Returns the index of the last element in the array
/// that satisfies the given predicate.
/// Return a NoMatchingElement Error if no such element exists.
let inline findIndexBack' predicate xs = findIndexBackSafe predicate xs

/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is f and the elements are i0...iN and j0...jN
/// then computes f (... (f s i0 j0)...) iN jN.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let fold2Safe folder initialState xs ys = 
  if Array.length xs = Array.length ys
  then Ok <| Array.fold2 folder initialState xs ys
  else Error <| fold2Err (Array.length xs) (Array.length ys)

/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is f and the elements are i0...iN and j0...jN
/// then computes f (... (f s i0 j0)...) iN jN.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline fold2' folder initialState xs ys = fold2Safe folder initialState xs ys

/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is f and the elements are i0...iN and j0...jN
/// then computes f i0 j0 (...(f iN jN s)).
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let foldBack2Safe folder xs ys initialState = 
  if Array.length xs = Array.length ys
  then Ok <| Array.foldBack2 folder xs ys initialState 
  else Error <| fold2Err (Array.length xs) (Array.length ys)

/// Applies a function to corresponding elements of two collections, threading an accumulator argument
/// through the computation. The collections must have identical sizes.
/// If the input function is f and the elements are i0...iN and j0...jN
/// then computes f i0 j0 (...(f iN jN s)).
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline foldBack2' folder xs ys initialState = foldBack2Safe folder xs ys initialState

/// Returns the first element of the array.
/// Returns a SeqIsEmpty error if <c>xs</c> has no elements.
let headSafe xs =
  if Array.isEmpty xs 
  then Error headErr
  else Ok <| Array.head xs

/// Returns the first element of the array.
/// Returns a SeqIsEmpty error if <c>xs</c> has no elements.
let inline head' xs = headSafe xs

/// Computes the element at the specified index in the collection.
/// Returns an IndexOutOfRange Error if the index is negative or exceeds the size of the collection.
let itemSafe index xs = 
  if index < 0
    then Error <| indexNegativeErr index
  elif Array.length xs <= index
    then Error <| indexTooLargeErr index (Array.length xs)
  else 
    Ok <| xs.[index]  

/// Computes the element at the specified index in the collection.
/// Returns an IndexOutOfRange Error if the index is negative or exceeds the size of the collection.
let inline item' index xs = itemSafe index xs

/// Applies the given function to two collections simultaneously. The collections must have identical size.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let iter2Safe action xs ys = 
  if Array.length xs = Array.length ys 
  then Ok <| Array.iter2 action xs ys
  else Error <| iter2Err (Array.length xs) (Array.length ys)

/// Applies the given function to two collections simultaneously. The collections must have identical size.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline iter2' action xs ys = iter2Safe action xs ys

/// Applies the given function to two collections simultaneously. The
/// collections must have identical size. The integer passed to the
/// function indicates the index of element.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let iteri2Safe action xs ys = 
  if Array.length xs = Array.length ys 
  then Ok <| Array.iteri2 action xs ys
  else Error <| iteri2Err (Array.length xs) (Array.length ys)

/// Applies the given function to two collections simultaneously. The
/// collections must have identical size. The integer passed to the
/// function indicates the index of element.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline iteri2' action xs ys = iteri2Safe action xs ys 

/// Returns the last element of the array.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let lastSafe xs = Array.tryLast xs |> Result.ofOption lastErr  

/// Returns the last element of the array.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let inline last' xs = lastSafe xs

/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the two collections pairwise.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let map2Safe f xs ys = 
  if Array.length xs = Array.length ys 
  then Ok <| Array.map2 f xs ys
  else Error <| map2Err (Array.length xs) (Array.length ys)

/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the two collections pairwise.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline map2' f xs ys = map2Safe f xs ys

/// Like mapi, but mapping corresponding elements from two arrays of equal length.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let mapi2Safe f xs ys =
  if Array.length xs = Array.length ys 
  then Ok <| Array.mapi2 f xs ys
  else Error <| mapi2Err (Array.length xs) (Array.length ys)

/// Like mapi, but mapping corresponding elements from two arrays of equal length.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline mapi2' f xs ys = mapi2Safe f xs ys

/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the three collections simultaneously.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let map3Safe f xs ys zs = 
  if Array.length xs = Array.length ys && Array.length xs = Array.length zs
  then Ok <| Array.map3 f xs ys zs
  else Error <| map3Err (Array.length xs) (Array.length ys) (Array.length zs)

/// Builds a new collection whose elements are the results of applying the given function
/// to the corresponding elements of the three collections simultaneously.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline map3' f xs ys zs = map3Safe f xs ys zs

/// Returns the greatest of all elements of the array, compared via Operators.max.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let maxSafe<'a when 'a : comparison> (xs:'a array) =
  if Array.isEmpty xs 
  then Error <| maxErr
  else Ok <| Array.max xs

/// Returns the greatest of all elements of the array, compared via Operators.max.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let inline max'<'a when 'a : comparison> (xs:'a array) = maxSafe xs

/// Returns the greatest of all elements of the array, compared via Operators.max on the function result.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let maxBySafe<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a array) =
  if Array.isEmpty xs
  then Error <| maxErr
  else Ok <| Array.maxBy projection xs

/// Returns the greatest of all elements of the array, compared via Operators.max on the function result.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let inline maxBy'<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a array) = maxBySafe projection xs

/// Returns the lowest of all elements of the array, compared via Operators.min.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let minSafe<'a when 'a : comparison> (xs:'a array) =
  if Array.isEmpty xs 
  then Error <| minErr
  else Ok <| Array.min xs

/// Returns the lowest of all elements of the array, compared via Operators.min.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let inline min'<'a when 'a : comparison> (xs:'a array) = minSafe xs

/// Returns the lowest of all elements of the array, compared via Operators.min on the function result.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let minBySafe<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a array) =
  if Array.isEmpty xs 
  then Error <| minErr
  else Ok <| Array.minBy projection xs

/// Returns the lowest of all elements of the array, compared via Operators.min on the function result.
/// Returns a SeqIsEmpty Error if <c>xs</c> has no elements.
let inline minBy'<'a, 'b when 'b : comparison> (projection:'a -> 'b) (xs:'a array) = minBySafe projection xs

/// Applies the given function to successive elements, returning the first
/// result where the function returns "Some(x)".
/// Return a NoMatchingElement Error if no such element exists.
let pickSafe chooser xs = 
  Array.tryPick chooser xs
  |> Result.ofOption pickErr

/// Applies the given function to successive elements, returning the first
/// result where the function returns "Some(x)".
/// Return a NoMatchingElement Error if no such element exists.
let inline pick' chooser xs = pickSafe chooser xs

/// Applies a function to each element of the array, threading an accumulator argument
/// through the computation. Begin by applying the function to the first two elements.
/// Then feed this result into the function along with the third element and so on.
/// Return the final result.
/// Returns a SeqIsEmpty Error if the array is empty.
let reduceSafe reduction xs = 
  if Array.isEmpty xs
  then Error <| reduceErr
  else Ok <| Array.reduce reduction xs

/// Applies a function to each element of the array, threading an accumulator argument
/// through the computation. Begin by applying the function to the first two elements.
/// Then feed this result into the function along with the third element and so on.
/// Return the final result.
/// Returns a SeqIsEmpty Error if the array is empty.
let inline reduce' reduction xs = reduceSafe reduction xs

/// Applies a function to each element of the array, starting from the end, threading an accumulator argument
/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
/// then computes <c>f i0 (...(f iN-1 iN))</c>.
/// Returns a SeqIsEmpty Error if the array is empty.
let reduceBackSafe reduction xs = 
  if Array.isEmpty xs
  then Error <| reduceErr
  else Ok <| Array.reduceBack reduction xs

/// Applies a function to each element of the array, starting from the end, threading an accumulator argument
/// through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
/// then computes <c>f i0 (...(f iN-1 iN))</c>.
/// Returns a SeqIsEmpty Error if the array is empty.
let inline reduceBack' reduction xs = reduceBackSafe reduction xs 

/// Returns a array that skips N elements of the underlying array and then yields the
/// remaining elements of the array.
/// Returns a NotEnoughElements Error if <c>count</c> exceeds the length of <c>xs</c> 
let skipSafe count xs =
  if (Array.length xs >= count) || count < 0
  then Ok <| Array.skip count xs
  else Error <| lazySkipErr count 

/// Returns a array that skips N elements of the underlying array and then yields the
/// remaining elements of the array.
/// Returns a NotEnoughElements Error if <c>count</c> exceeds the length of <c>xs</c> 
let inline skip' count xs = skipSafe count xs

/// Splits a array into two arrays, at the given index.
/// Returns an IndexOutOfBounds Error when split index exceeds 
/// the number of elements in the array.
let splitAtSafe index xs = 
  if index < 0 
    then Error <| indexNegativeErr index
  elif index > Array.length xs
    then Error <| indexTooLargeErr index (Array.length xs)
  else
    Ok <| Array.splitAt index xs

/// Splits a array into two arrays, at the given index.
/// Returns an IndexOutOfBounds Error when split index exceeds 
/// the number of elements in the array.
let inline splitAt' index xs = splitAtSafe index xs 

/// Splits the input array into at most count chunks.
/// Returns a NegativeInput Error if <c>count</c> is not positive.
let splitIntoSafe count xs = 
  if count > 0 
  then Ok <| Array.splitInto count xs
  else Error <| splitIntoErr count

/// Splits the input array into at most count chunks.
/// Returns a NegativeInput Error if <c>count</c> is not positive.
let inline splitInto' count xs = splitIntoSafe count xs

/// Slices an array given a starting index and a count of elements to return.
/// Returns an IndexOutOfBounds Error if either <c>startIndex<c/> or <c>count<c/> is negative,
/// or if there aren't enough elements in the input array.
/// (This is computed if the <c>startIndex<c/> + the <c>count<c/> is greater
/// than the length of the array.  Note that it returns an empty array if <c>startIndex<c/>
/// is equal to the length of the array and the <c>count<c/> is 0.)
let subSafe xs startIndex count = 
  if startIndex < 0 then Error <| namedIndexNegativeErr "startIndex" startIndex
  elif count < 0 then Error <| namedIndexNegativeErr "count" count
  elif startIndex + count > Array.length xs then Error <| subErr startIndex count (Array.length xs)
  else Ok <| Array.sub xs startIndex count

/// Slices an array given a starting index and a count of elements to return.
/// Returns an IndexOutOfBounds Error if either <c>startIndex<c/> or <c>count<c/> is negative,
/// or if there aren't enough elements in the input array.
/// (This is computed if the <c>startIndex<c/> + the <c>count<c/> is greater
/// than the length of the array.  Note that it returns an empty array if <c>startIndex<c/>
/// is equal to the length of the array and the <c>count<c/> is 0.)
let inline sub' xs startIndex count = subSafe xs startIndex count

/// Returns a array that skips 1 element of the underlying array and then yields the
/// remaining elements of the array.
/// Returns a SeqIsEmpty Error if <c>xs</c> contains no elements.
let tailSafe xs = 
  if Array.isEmpty xs 
  then Error <| tailErr
  else Ok <| Array.tail xs

/// Returns a array that skips 1 element of the underlying array and then yields the
/// remaining elements of the array.
/// Returns a SeqIsEmpty Error if <c>xs</c> contains no elements.
let inline tail' xs = tailSafe xs

/// Returns the first N elements of the array.
/// Returns a NotEnoughElements Error if <c>count</c> exceeds the length of <c>xs</c> 
let takeSafe count xs = 
  if Array.length xs >= count && count >= 0
  then Ok <| Array.take count xs
  else Error <| lazyTakeErr count

/// Returns the first N elements of the array.
/// Returns a NotEnoughElements Error if <c>count</c> exceeds the length of <c>xs</c> 
let inline take' count xs = takeSafe count xs

/// Returns a array that yields sliding windows containing elements drawn from the input
/// array. Each window is returned as a fresh array.
/// Returns a NegativeInput Error when <c>size</c> is not positive.
let windowedSafe size xs = 
  if size > 0 
  then Ok <| Array.windowed size xs
  else Error <| windowedErr size

/// Returns a array that yields sliding windows containing elements drawn from the input
/// array. Each window is returned as a fresh array.
/// Returns a NegativeInput Error when <c>size</c> is not positive.
let inline windowed' size xs = windowedSafe size xs

/// Combines the two arrays into a array of pairs. The two arrays must have equal lengths.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let zipSafe xs ys = 
  if Array.length xs = Array.length ys
  then Ok <| Array.zip xs ys 
  else Error <| zipErr (Array.length xs) (Array.length ys)

/// Combines the two arrays into a array of pairs. The two arrays must have equal lengths.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline zip' xs ys = zipSafe xs ys

/// Combines the three arrays into a array of triples. The arrays must have equal lengths.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let zip3Safe xs ys zs = 
  if Array.length xs = Array.length ys && Array.length xs = Array.length zs
  then Ok <| Array.zip3 xs ys zs
  else Error <| zip3Err (Array.length xs) (Array.length ys) (Array.length zs)

/// Combines the three arrays into a array of triples. The arrays must have equal lengths.
/// Returns a DifferingLengths Error if the input arrays have a different number of elements.
let inline zip3' xs ys zs = zip3Safe xs ys zs

//TODO: transpose, split once we use a newer FSharp.Core
